---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Bayesian Hierarchial Spatial Province Models for _P. vivax_ among Asymptomatic Adults in the DRC"


```{r, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F, eval = T, results = 'hide',
                      fig.align = 'center', fig.width = 8, fig.height = 8)

```

```{r}
source("~/Documents/GitHub/VivID_Epi/R/00-functions_basic.R") 
source("~/Documents/GitHub/VivID_Epi/R/00-functions_epi.R") 
source("~/Documents/GitHub/VivID_Epi/R/00-MCMC_diagnostics.R")
library(tidyverse)
library(srvyr) #wrap the survey package in dplyr syntax
library(CARBayes)
library(raster)
set.seed(48)
tol <- 1e-3

#......................
# Import Data
#......................
dt <- readRDS("~/Documents/GitHub/VivID_Epi/data/derived_data/vividepi_recode_completecases.rds")
dtsrvy <- makecd2013survey(survey = dt)
mp <- readRDS("~/Documents/GitHub/VivID_Epi/data/derived_data/basic_cluster_mapping_data.rds")
ge <- readRDS(file = "~/Documents/GitHub/VivID_Epi/data/raw_data/dhsdata/VivIDge.RDS")

```

```{r}

#------------------------------------------------------------------------
# Subset to Pv
#------------------------------------------------------------------------
pvprov.weighted <- mp$data[mp$plsmdmspec == "pv18s" & mp$maplvl == "adm1name"][[1]]
# vectors have destroyed spatial class, need to remake
pvprov.weighted <- sf::st_as_sf(pvprov.weighted)
sf::st_crs(pvprov.weighted) <-  sf::st_crs(ge)
# need ints (binomail prob), so will round
pvprov.weighted <- pvprov.weighted %>% 
  dplyr::mutate(plsmdn = round(plsmdn, 0),
                n = round(n, 0))

pvprov.weighted.nosf <- pvprov.weighted
sf::st_geometry(pvprov.weighted.nosf) <- NULL

```

```{r}
#-------------------------------------------------------------------------
# Aggregate Covariates
# means within each adm1
#-------------------------------------------------------------------------
precip <- readRDS("~/Documents/GitHub/VivID_Epi/data/derived_data/vividepi_precip_study_period_effsurface.rds")
temp <- readRDS("~/Documents/GitHub/VivID_Epi/data/derived_data/vividepi_temperature_study_period_effsurface.rds")
cropland <- readRDS("~/Documents/GitHub/VivID_Epi/data/derived_data/vividepi_cropland_surface.rds")
nightlights <- raster::raster("~/Documents/GitHub/VivID_Epi/data/derived_data/vividepi_nightlights_surface.grd")


extract_agg_raster_polygon <- function(rstrlyr, plygn){
  vals <- raster::extract(x = rstrlyr, y = sf::as_Spatial(plygn),
                          fun = mean,
                          na.rm = T, 
                          sp = F
                          )
  return(as.vector(vals))
  
}

# split admins
adm1 <- pvprov.weighted %>% 
  dplyr::select(c("adm1name", "geometry"))
adm1 <- split(adm1, 1:nrow(adm1))

pvcovar <- pvprov.weighted %>% 
  dplyr::select(c("adm1name"))


pvcovar$precip <- unlist( lapply(adm1, extract_agg_raster_polygon, rstrlyr = precip) )
pvcovar$temp <- unlist( lapply(adm1, extract_agg_raster_polygon, rstrlyr = temp) )
pvcovar$crop <- unlist( lapply(adm1, extract_agg_raster_polygon, rstrlyr = cropland) )
pvcovar$nightlight <- unlist( lapply(adm1, extract_agg_raster_polygon, rstrlyr = nightlights) )


pvcovar$precip_scale <- my.scale(pvcovar$precip)
pvcovar$temp_scale <- my.scale(pvcovar$temp)
pvcovar$crop_scale <- my.scale(logit(pvcovar$crop, tol = tol))
pvcovar$nightlight_scale <- my.scale(pvcovar$nightlight)
sf::st_geometry(pvcovar) <- NULL

# combine
pvprov.weighted.nosf <- dplyr::left_join(pvprov.weighted.nosf, pvcovar, by = "adm1name")


```


## Hierarchial Bayesian Spatial Models for Province Prevalence 
### Make Model Framework
NB. When $\rho$ is `NULL`, it is estimated within the CAR model. As a result, we have three scenarios based on the _Leroux et al. 2000_ specifiation of the Gaussian Markov Random Field: (1) independent random effects ($\rho = 0$), (2) Intrinsic CAR (e.g. complete spatial dependence, $\rho = 1$), and (3) CAR where $\rho$ is estimated under the model.

```{r, results='asis'}

#-------------------------------------------------------------------------
# Conditional Autoregressive Spatial Model 
#-------------------------------------------------------------------------
#......................
# Make Adjacency Matrix for Pv 
#......................
W.nb <- spdep::poly2nb(sf::as_Spatial(pvprov.weighted), row.names = pvprov.weighted$adm1name)
W <- spdep::nb2mat(W.nb, style = "B") # binary weights taking values zero or one (only one is recorded)

#......................
# Make Model Framework
#......................
prov.covar.names <- c("precip_scale", "temp_scale", "crop_scale", "nightlight_scale")
mod.framework <- tibble(name = c("riid_intercept", "ICAR_intercept", 
                                 "CAR_intercept", "riid_covar", "ICAR_covar", "CAR_covar"),
                        formula = c("plsmdn ~ 1", "plsmdn ~ 1", "plsmdn ~ 1",
                                    rep(paste0("plsmdn ~ ", paste(prov.covar.names, collapse = " + ")), 3)),
                        rho = c(0, 1, NA, 0, 1, NA),
                        burnin = 1e3,
                        n.sample = 1e4 + 1e3,
                        family = "binomial"
                        )


mod.framework$trials <- lapply(1:nrow(mod.framework), function(x) return(pvprov.weighted.nosf$n))
mod.framework$data <- lapply(1:nrow(mod.framework), function(x) return(pvprov.weighted.nosf))
mod.framework$W <- lapply(1:nrow(mod.framework), function(x) return(W))

mod.framework %>% 
  dplyr::select(-c("data", "trials", "W")) %>% 
  knitr::kable(.)

```


#### Diagnostic Chains
Run out four diagnostic chains to check convergence. 
```{r}

# replicate this four times for our four chains
mod.framework <- lapply(1:4, function(x) return(mod.framework)) %>% 
  dplyr::bind_rows() %>% 
  dplyr::arrange(name)

#......................
# Make a wrapper for CARBAYES
#......................
wrap_S.CARleroux <- function(name, formula, family, trials, W, rho, data, burnin, n.sample){
  
  formvec <- paste(formula, collapse = "")
  betacount <- stringr::str_count(formvec, "\\+") + 2 # need intercept and betas
  betacount <- ifelse(grepl("1", formvec), 1, betacount) # corner case of just intercept
  prior.var.betavec <- rep(5e4, betacount) # note prior setting here
  
  
  # don't need name but want it here for posterity
  if(!is.na(rho)){
    ret <- CARBayes::S.CARleroux(formula = as.formula(formula), 
                                 family = family, 
                                 trials = trials, 
                                 W = W,
                                 rho = rho,
                                 data = data,
                                 burnin = burnin, 
                                 prior.var.beta = prior.var.betavec,
                                 prior.tau2 = c(1, 0.01),
                                 n.sample = n.sample)
  } else if(is.na(rho)){ # rho needs to be NULL which has a hard time in a vector
    ret <- CARBayes::S.CARleroux(formula = as.formula(formula), 
                                 family = family, 
                                 trials = trials, 
                                 W = W,
                                 data = data,
                                 burnin = burnin, 
                                 prior.var.beta = prior.var.betavec,
                                 n.sample = n.sample)
  }
  
  return(ret)
}


mod.framework$MCMC <- purrr::pmap(mod.framework, wrap_S.CARleroux)

```

#### MCMC Diagnostics 
Note, our goal is to have the effective sample sizes (`n.effective`) to be at least 500 for all parameters. In addition, we will visually check for convergence among the four chains. 

##### Param Diagnostics
```{r}
#-------------------------------------------------------------------------
# MCMC Diagnostics
#-------------------------------------------------------------------------
mod.framework$mcmc.modsum <- purrr::map(mod.framework$MCMC, print) # note, print is overloaded here
mod.framework$summresults <- purrr::map(mod.framework$mcmc.modsum, "summary.results")
mod.framework$summresults <- purrr::map(mod.framework$summresults, function(x){
  pars <- rownames(x)
  ret <- cbind.data.frame(pars = pars, as.data.frame(x))
  return(ret)
  })

```

```{r, results='asis'}
mod.framework %>% 
  dplyr::select(c("name", "formula", "rho", "summresults")) %>% 
  tidyr::unnest(cols = "summresults") %>% 
  dplyr::mutate(
    name = kableExtra::cell_spec(name, "html", 
                                 color = kableExtra::spec_color(1:length(levels(factor(name))), end = 0.9)),
     formula = kableExtra::cell_spec(formula, "html", 
                                     color = kableExtra::spec_color(1:length(levels(factor(formula))), end = 0.9))) %>% 
  kableExtra::kable(format = "html", escape = F) %>%
  kableExtra::kable_styling("striped", full_width = F) %>% 
  kableExtra::pack_rows("Chain Set 1", 1, 16) %>%
  kableExtra::pack_rows("Chain Set 2", 17, 28) %>% 
  kableExtra::pack_rows("Chain Set 3", 29, 44) %>% 
  kableExtra::pack_rows("Chain Set 4", 45, 56) %>% 
  kableExtra::pack_rows("Chain Set 5", 57, 72) %>% 
  kableExtra::pack_rows("Chain Set 6", 73, 84) 
```

```{r, results='asis'}
mod.framework %>% 
  dplyr::select(c("name", "formula", "rho", "summresults")) %>% 
  tidyr::unnest(cols = "summresults") %>% 
    DT::datatable(., 
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 5,
                  dom = 'Bfrtip', 
                  buttons = c('csv')))
```

##### Diagnostic Chains
Note, there are too many chains for visualizing here. Writing out to local directory. 
```{r}

#............................
# Let's Look at the Chains
#............................
mod.framework$samples <- purrr::map(mod.framework$MCMC, "samples")
mod.framework$betachains <- purrr::map(mod.framework$samples, "beta")
mod.framework$phichains <- purrr::map(mod.framework$samples, "phi")
mod.framework$tau2chains <- purrr::map(mod.framework$samples, "tau2")
mod.framework$rhochains <- purrr::map(mod.framework$samples, "rho")
mod.framework$fittedchains <- purrr::map(mod.framework$samples, "fitted")


chains <- mod.framework %>% 
  dplyr::select(c("name", "betachains", "phichains", "tau2chains", "rhochains", "fittedchains")) %>% 
  dplyr::group_by(name) %>% 
  tidyr::nest()

mydiagnosticdir <- "~/Documents/GitHub/VivID_Epi/analyses/07-spatial_prediction/prov_map_diagnostic_chains/"
dir.create(mydiagnosticdir, recursive = T)
wrap_chain_plotter.carbayes.diag(diag.dir = mydiagnosticdir, chains = chains)


```

## Final Long Chain
Now, we will run out one final long chain with 1e5 burnin iterations and 1e8 sampling iterations for each of our base models. 

```{r}

mod.framework.long <- mod.framework[,c("name", "formula", "family", "trials", "W", "rho", "data", "burnin", "n.sample")] %>% 
  dplyr::filter(!duplicated(.))

mod.framework.long$burnin <- 1e3
mod.framework.long$n.sample <- 1e5 + 1e3

mod.framework.long$MCMC <- pmap(mod.framework.long, wrap_S.CARleroux)


```

#### Long Chain MCMC Diagnostics 
Note, our goal is still to have the effective sample sizes (`n.effective`) to be at least 1,000 for all parameters. In addition, we will visually check for convergence among the four chains. 

##### Long Chain Param Diagnostics

```{r}
#-------------------------------------------------------------------------
# MCMC Diagnostics
#-------------------------------------------------------------------------
mod.framework.long$mcmc.modsum <- purrr::map(mod.framework.long$MCMC, print) # note, print is overloaded here
mod.framework.long$summresults <- purrr::map(mod.framework.long$mcmc.modsum, "summary.results")
mod.framework.long$summresultsdf <- purrr::map(mod.framework.long$summresults, function(x){
  pars <- rownames(x)
  ret <- cbind.data.frame(pars = pars, as.data.frame(x))
  return(ret)
})

mod.framework.long.res <- mod.framework.long %>% 
  dplyr::select(c("name", "formula", "rho", "summresultsdf")) %>% 
  tidyr::unnest(cols = "summresultsdf") 
```

```{r, results='asis'}
mod.framework.long.res %>% 
  dplyr::mutate(
    name = kableExtra::cell_spec(name, "html", 
                                 color = kableExtra::spec_color(1:length(levels(factor(name))), end = 0.9)),
    formula = kableExtra::cell_spec(formula, "html", 
                                    color = kableExtra::spec_color(1:length(levels(factor(formula))), end = 0.9))) %>% 
  kableExtra::kable(format = "html", escape = F) %>%
  kableExtra::kable_styling("striped", full_width = F) 
```

```{r, results='asis'}
mod.framework.long.res %>% 
    DT::datatable(., 
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 5,
                  dom = 'Bfrtip', 
                  buttons = c('csv')))
```


### Long Chain DIC

```{r}


mod.framework.long$modfit <- purrr::map(mod.framework.long$mcmc.modsum, "modelfit")

# note in order to be consistent, with the PrevMap approach,
# I want Gelman's DIC: DICg = mu + sigma
# can get this from the log likelihood provided by CarBayes. 

# CarBayes nicely outputs the Fitted Values, from which I can calculate a log-likelihood
dimnames(mod.framework.long$W[[1]])[[1]]

mod.framework.long$LL <- purrr::pmap(mod.framework.long[, c("data", "trials", "MCMC")], 
  function(data, trials, MCMC){
  Yi <- data$plsmdn
  ni <- trials
  Ti <- MCMC$samples$fitted
  
  LL <- c()
  for(s in 1:nrow(Ti)){ # for every sim
    LL.iter <- 0
    for(i in 1:ncol(Ti)){ # for every spatial unit
      LL.iter <- dbinom(x = Yi[i], size = ni[i], prob = Ti[s, i]/ni[i], log = T) + LL.iter
      LL.iter
    }
    LL <- append(LL.iter, LL)
    
  }
  
  LL <- return(LL)
})


mod.framework.long$DICg <- purrr::map(mod.framework.long$LL, function(x){
  mu = mean(x)
  sigma = var(x)/2
  DICg = mu + sigma
  return(DICg)
})


mod.framework.long$DICs <- purrr::map(mod.framework.long$modfit, "DIC")


```

```{r, results='asis'}
data.frame(name = mod.framework.long$name, DICg = unlist(mod.framework.long$DICg),
           DICs = unlist(mod.framework.long$DICs)) %>% 
  DT::datatable(., 
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip', 
                  buttons = c('csv')))

```


```{r}

# write out these final models
dir.create("~/Documents/GitHub/VivID_Epi/results/tables/", recursive = T)
readr::write_csv(x = mod.framework.long.res, path = "~/Documents/GitHub/VivID_Epi/results/tables/Prov_Level_HierBayesSP_models.csv")


dir.create("~/Documents/GitHub/VivID_Epi/analyses/07-spatial_prediction/prov_map_long_chains/", recursive = T)
saveRDS(mod.framework.long, 
        file = "~/Documents/GitHub/VivID_Epi/analyses/07-spatial_prediction/prov_map_long_chains/Province_Bayes_Hierarchial_Model_longchain.rds")



```

Note, still a lot of chains for visualizing here. Writing out to local directory. 
```{r}

#............................
# Let's Look at the final chain
#............................
mod.framework.long$samples <- purrr::map(mod.framework.long$MCMC, "samples")
mod.framework.long$betachains <- purrr::map(mod.framework.long$samples, "beta")
mod.framework.long$phichains <- purrr::map(mod.framework.long$samples, "phi")
mod.framework.long$tau2chains <- purrr::map(mod.framework.long$samples, "tau2")
mod.framework.long$rhochains <- purrr::map(mod.framework.long$samples, "rho")
mod.framework.long$fittedchains <- purrr::map(mod.framework.long$samples, "fitted")


chains <- mod.framework.long %>% 
  dplyr::select(c("name", "betachains", "phichains", "tau2chains", "rhochains", "fittedchains")) %>% 
  dplyr::group_by(name) %>% 
  tidyr::nest()

myfinalchain <- "~/Documents/GitHub/VivID_Epi/analyses/07-spatial_prediction/prov_map_final_long_chain/"
dir.create(myfinalchain, recursive = T)
wrap_chain_plotter.carbayes.final(final.dir = myfinalchain, chains = chains)


```
